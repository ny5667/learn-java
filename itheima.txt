* 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?

类型有堆 和 栈

int 类型是 **栈**

String 类型是 **堆**

JVM运行时数据区域：
方法区：原空间，存储类的信息，方法信息，静态变量，运行时常量，常量池，多个线程共享的
堆区：多个线程共享的，存储一些对象的，分为新生代和老年代，新生代分为伊甸区和存活区，15次gc后从存活区到老年区
程序计数器：每个线程单独有一个，记录当前线程执行的指令地址，因为线程会切换
虚拟机栈：每个线程独有的，我当前这个线程当前执行的是哪个方法，每执行一个方法都生成一个栈帧回到虚拟机栈中去，执行结束了也就出栈
本地方法栈：去在本地的native方法，每个线程所独有的，

JVM调优策略
1、内存分配——根据数据量增加堆内存和非堆内存
2、垃圾回收——选择不同的垃圾回收器，调整垃圾回收器的参数和内存阈值
3、线程管理——通过调整线程的数量，设置线程的优先级和使用线程池等方式
4、类加载——优化类的加载过程，提高程序启动速度和响应速度
5、编译优化——设置JIT编译器的参数和选择造当的编译器
6、I/O优化——通过使用缓冲区，选择合适的IO库，减少IO操作次数等方式

HashMap，线程不安全
HashTable，线程安全，一把锁，ConcurrentHashMap使用“分段锁”

1.并发队列-阻塞队列
BlockingQueue阻塞队列，插入offer(e)，移除poll()
LinkedBlockingQueue
PriorityBlockingQueue：
无界队列，使用cas进行扩容，增加了并发性
进队cas：https://cloud.tencent.com/developer/article/1330391
SychronousQueue同步队列
DeplayQueue延时无界阻塞队列：
缓存应用实例：
https://blog.csdn.net/weixin_44629395/article/details/123180124

并发队列-非阻塞队列
ConcurrentLinkedQueue非阻塞无界链表队列
解析：
https://www.cnblogs.com/pony1223/p/9509205.html
https://blog.csdn.net/weixin_38003389/article/details/85413150
ConcurrentHashMap非阻塞Hash集合
ConcurrentSkipListMap非阻塞Hash跳表集合
解析：
https://www.cnblogs.com/java-zzl/p/9767255.html
AtomicIntegerArray:
解析：
https://blog.csdn.net/qq_43776408/article/details/100148988
AtomicLongArray原子性整形数组

多线程面试题：
多线程的创建方式：
 1.继承Thread类，并复写run()方法
 2.实现Runnable接口，并复写run()方法
 3.实现Callable，可以获取一个Future的对象
在java中wait和sleep方法的不同？
 在等待时wait会释放锁，而sleep一起持有锁。wait通常用于线程间交互，sleep通常被 用于暂停执行
synchronized和volatile关键字的作用
 volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
 volatile仅能使用在变量级别，synchronized则可以使用在变量、方法和类级别
 volatile仅能实现变量的修改可见性，并不能保证原子性。synchronized则可以保证变量的修改可见性和原子性
 volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞
 volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化
如何控制某个方法允许并发访问线程的个数
 用Semaphore(5,true)变量
三个线程a、b、c并发支持，b、c需要a线程的数据怎么实现？
 定义new Semaphore(0)，a中release(2)，b中进行acquire，c中进行acquire
同一个类中的2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗?Lock可以让等待锁的线程响应中断，Lock获取锁，之后需要释放锁。
什么情况下导致线程死锁，遇到线程死锁该怎么解决？
 1、互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待。
2、剥夺条件：线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己来释放。
3、请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4、循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程请求。
如何避免死锁
1、加锁顺序（线程按照一定的顺序加锁）
2、加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
Java中多线程间的通信怎么实现
1、共享变量
2、wait/notify机制
线程和进程的区别
进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位
线程：是进程的一个实体，是cpu调度和分派的基本单位，是比进程更小的可以独立运行的基本单位。
特点：线程的划分尺度小于进程，这便多线程程序拥有高并发性，进程在运行时各自内存单元相互独立，线程之间内存共享，这使多线程编程可以拥有更好的性能和用户体验
请说出同步线程及线程调度相关的方法
wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁
sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常
notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程而是由JVM确定唤醒哪个线程，而且与优先级无关
notifyAll()：唤醒所有处于等待的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态
说说你对Java中反射的理解/获得一个类对象有哪些方式？
类名.class()；对象名.getClass()；Class.forName(具体的类名)；
https://blog.csdn.net/qq_39209361/article/details/81239189
Java中的动态代理：静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类；静态代理：接口和实现；动态代理：Spring实现，一个接口有多个实现；
设计模式：
创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
单例设计模式：分为懒汉式和饿汉式，推荐用猛汉式，用在数据库连接时。
工厂设计模式：
一、工厂方法模式：
1、普通工厂模式：一个SendFactory，通过字符串创建实现类。
2、多个工厂方法模式：一个SendFactory，创建多个实现类
3、静态工厂方法模式：同上，但创建方法改为静态方法
二、抽象工厂模式
Provider接口里定义发送方法，实现多个Factory类
二、建造者模式
https://cloud.tencent.com/developer/article/2361575
三、适配器设计模式：类的适配器模式、对象的适配器模式、接口的适配器模式
https://www.jianshu.com/p/c87265610d2a
接口实现所有方法，通过抽象方法来实现要实现的方法
https://blog.csdn.net/DGH2430284817/article/details/120421756
四、装饰模式
装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被 装饰对象的实例
五、策略模式
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象炽，提供辅助函数。策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封闭。因此，策略模式多用在算法决策系统中外部用户只需决定用哪个算法即可。
https://www.cnblogs.com/ysocean/p/15635852.html
六、观察者模式
观察者很好理解，当一个对象变化时，其它依赖对象的对象都会收到通知，并且随着变化。
JVM垃圾回收机制和常见算法
根搜索算法：根搜索算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链，当一个对象没有被GC Roots的引用链连接的时候，说明这个对象是不可用的。
GC Roots对象包括
a)虚拟机栈（栈帧的本地变量表）中的引用的对象
b)方法区域中的类静态属性引用的对象
c）方法区域中常量引用的对象
d)本地方法栈中JNI(Native方法）的引用的对象
回收算法：
1）标记——清除算法
2）复制算法
复制算法把内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上，然后把这块内存整个清理掉。主要用于新生代，由于新生代中大部分对象都是朝生夕死的。
3）标记——整理算法
把存活对象往内存的一端移动，然后直接回收边界以外的内存。适合在存活时间较长的老年代。
4）分代收集
根据对象的存活时间分为 新生代和老年代，用不同算法进行垃圾回收
谈谈JVM的内存结构和内存分配
a)Java内存模型，方法区，Java栈，Java堆
1、方法区是静态分配的——常数池，源代码中的命名常量，String常量和static变量保存在方法区
2、Java Stack——Java虚拟机每调用一次方法就创建一个方法帧，退出 该方法则对应的方法帧被弹出。栈中存储的数据也是运行时确定的
3、Java堆分配——心随意的顺序，在运行时进行存储空间分配和收回的内存管理模型
b)java内存分配
1、基础数据类型直接在栈空间分配
2、方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收
3、引用数据参数，需要用new来创建，在栈空间分配一个地址空间，又在堆空间分配对象的类变量；
4、方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完后从栈空间回收
5、局部变量new出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收
6、方法调用时传入的实际参数，先在栈空间分配，在方法调用完成后从栈空间释放
7、字符串常量在DATA区域分配，this在堆空间分配
8、数组既在栈空间分配数组名称，又在堆空间分配数组实际的大小
Java中引用类型都有哪些？
强引用、软引用、弱引用和虚引用
强引用：绝不会回收它，宁愿OutOfMemoryError
软引用：如何内存不足了，就会回收
弱引用：gc扫描到了随时都会干掉
虚引用：如果对象仅持有虚引用，和没有任务引用一样，任务时候都会被垃圾回收。主要用来跟踪垃圾回收活动

Java的类加载器的种类
1、根类加载器
2、扩展类加载器
3、系统（应用）类加载器
4、自定义加载器（必须继承ClassLoader）
类什么时候被初始化？
父类的静态变量，父类的静态方法块，子类的静态变量，子类的静态方法块，父类的构造方法，子类的构造方法

Java类加载体系之ClassLoader双亲委托机制
1、启动类加载器——BootStrapClassLoader
2、扩展类加载器——ExtClassLoader
3、应用程序类加载器——AppClassLoader
4、自定义类加载器——CustomClassLoader

既然有GC机制，为什么还会有内存泄露的情况：可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生

lambda表达式：
1、写的更简洁—— （() -> ）
2、对事件处理
3、.forEach（）对列表进行迭代
4、用Predicate，对数据进行过滤
5、用and()、or()、xor()对Predicate进行组合
6、用Reduce，进行Sum、avg()或者count()函数操作
7、filter方法
8、map方法，对每一项进行处理
9、distinct方法，进行去重
10、summaryStatistics方法，进行统计

看到320页
